= JSON Support

Cassandra 2.2 introduces JSON support to `SELECT <select-statement>` and
`INSERT <insert-statement>` statements. This support does not
fundamentally alter the CQL API (for example, the schema is still
enforced), it simply provides a convenient way to work with JSON
documents.

== SELECT JSON

With `SELECT` statements, the `JSON` keyword can be used to return each
row as a single `JSON` encoded map. The remainder of the `SELECT`
statement behavior is the same.

The result map keys are the same as the column names in a normal result
set. For example, a statement like `SELECT JSON a, ttl(b) FROM ...`
would result in a map with keys `"a"` and `"ttl(b)"`. However, this is
one notable exception: for symmetry with `INSERT JSON` behavior,
case-sensitive column names with upper-case letters will be surrounded
with double quotes. For example, `SELECT JSON myColumn FROM ...` would
result in a map key `"\"myColumn\""` (note the escaped quotes).

The map values will `JSON`-encoded representations (as described below)
of the result set values.

== INSERT JSON

With `INSERT` statements, the new `JSON` keyword can be used to enable
inserting a `JSON` encoded map as a single row. The format of the `JSON`
map should generally match that returned by a `SELECT JSON` statement on
the same table. In particular, case-sensitive column names should be
surrounded with double quotes. For example, to insert into a table with
two columns named "myKey" and "value", you would do the following:

[source,cql]
----
INSERT INTO mytable JSON '{ "\"myKey\"": 0, "value": 0}'
----

By default (or if `DEFAULT NULL` is explicitly used), a column omitted
from the `JSON` map will be set to `NULL`, meaning that any pre-existing
value for that column will be removed (resulting in a tombstone being
created). Alternatively, if the `DEFAULT UNSET` directive is used after
the value, omitted column values will be left unset, meaning that
pre-existing values for those column will be preserved.

== JSON Encoding of Cassandra Data Types

Where possible, Cassandra will represent and accept data types in their
native `JSON` representation. Cassandra will also accept string
representations matching the CQL literal format for all single-field
types. For example, floats, ints, UUIDs, and dates can be represented by
CQL literal strings. However, compound types, such as collections,
tuples, and user-defined types must be represented by native `JSON`
collections (maps and lists) or a JSON-encoded string representation of
the collection.

The following table describes the encodings that Cassandra will accept
in `INSERT JSON` values (and `fromJson()` arguments) as well as the
format Cassandra will use when returning data for `SELECT JSON`
statements (and `fromJson()`):

[cols=",,,",options="header",]
|===
|Type |Formats accepted |Return format |Notes
a|
____
`ascii`
____

a|
____
string
____

a|
____
string
____

a|
____
Uses JSON's `\u` character escape
____

a|
____
`bigint`
____

a|
____
integer, string
____

a|
____
integer
____

a|
____
String must be valid 64 bit integer
____

a|
____
`blob`
____

a|
____
string
____

a|
____
string
____

a|
____
String should be 0x followed by an even number of hex digits
____

a|
____
`boolean`
____

a|
____
boolean, string
____

a|
____
boolean
____

a|
____
String must be "true" or "false"
____

a|
____
`date`
____

a|
____
string
____

a|
____
string
____

a|
____
Date in format `YYYY-MM-DD`, timezone UTC
____

a|
____
`decimal`
____

a|
____
integer, float, string
____

a|
____
float
____

a|
____
May exceed 32 or 64-bit IEEE-754 floating point precision in client-side
decoder
____

a|
____
`double`
____

a|
____
integer, float, string
____

a|
____
float
____

a|
____
String must be valid integer or float
____

a|
____
`float`
____

a|
____
integer, float, string
____

a|
____
float
____

a|
____
String must be valid integer or float
____

a|
____
`inet`
____

a|
____
string
____

a|
____
string
____

a|
____
IPv4 or IPv6 address
____

a|
____
`int`
____

a|
____
integer, string
____

a|
____
integer
____

a|
____
String must be valid 32 bit integer
____

a|
____
`list`
____

a|
____
list, string
____

a|
____
list
____

a|
____
Uses JSON's native list representation
____

a|
____
`map`
____

a|
____
map, string
____

a|
____
map
____

a|
____
Uses JSON's native map representation
____

a|
____
`smallint`
____

a|
____
integer, string
____

a|
____
integer
____

a|
____
String must be valid 16 bit integer
____

a|
____
`set`
____

a|
____
list, string
____

a|
____
list
____

a|
____
Uses JSON's native list representation
____

a|
____
`text`
____

a|
____
string
____

a|
____
string
____

a|
____
Uses JSON's `\u` character escape
____

a|
____
`time`
____

a|
____
string
____

a|
____
string
____

a|
____
Time of day in format `HH-MM-SS[.fffffffff]`
____

a|
____
`timestamp`
____

a|
____
integer, string
____

a|
____
string
____

a|
____
A timestamp. Strings constant allows to input `timestamps
as dates <timestamps>`. Datestamps with format `YYYY-MM-DD HH:MM:SS.SSS`
are returned.
____

a|
____
`timeuuid`
____

a|
____
string
____

a|
____
string
____

a|
____
Type 1 UUID. See `constant` for the UUID format
____

a|
____
`tinyint`
____

a|
____
integer, string
____

a|
____
integer
____

a|
____
String must be valid 8 bit integer
____

a|
____
`tuple`
____

a|
____
list, string
____

a|
____
list
____

a|
____
Uses JSON's native list representation
____

a|
____
`UDT`
____

a|
____
map, string
____

a|
____
map
____

a|
____
Uses JSON's native map representation with field names as keys
____

a|
____
`uuid`
____

a|
____
string
____

a|
____
string
____

a|
____
See `constant` for the UUID format
____

a|
____
`varchar`
____

a|
____
string
____

a|
____
string
____

a|
____
Uses JSON's `\u` character escape
____

a|
____
`varint`
____

a|
____
integer, string
____

a|
____
integer
____

a|
____
Variable length; may overflow 32 or 64 bit integers in client-side
decoder
____

|===

== The fromJson() Function

The `fromJson()` function may be used similarly to `INSERT JSON`, but
for a single column value. It may only be used in the `VALUES` clause of
an `INSERT` statement or as one of the column values in an `UPDATE`,
`DELETE`, or `SELECT` statement. For example, it cannot be used in the
selection clause of a `SELECT` statement.

== The toJson() Function

The `toJson()` function may be used similarly to `SELECT JSON`, but for
a single column value. It may only be used in the selection clause of a
`SELECT` statement.
