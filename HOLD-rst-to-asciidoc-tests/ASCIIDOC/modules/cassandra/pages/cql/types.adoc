= Data Types

CQL is a typed language and supports a rich set of data types, including
`native types <native-types>`, `collection types <collections>`,
`user-defined types <udts>`, `tuple types <tuples>` and `custom
types <custom-types>`:

cql_type: [.title-ref]#native_type# | [.title-ref]#collection_type# |
[.title-ref]#user_defined_type# | [.title-ref]#tuple_type# |
[.title-ref]#custom_type#

== Native Types

The native types supported by CQL are:

native_type: ASCII : | BIGINT : | BLOB : | BOOLEAN : | COUNTER : | DATE
: | DECIMAL : | DOUBLE : | DURATION : | FLOAT : | INET : | INT : |
SMALLINT : | TEXT : | TIME : | TIMESTAMP : | TIMEUUID : | TINYINT : |
UUID : | VARCHAR : | VARINT

The following table gives additional informations on the native data
types, and on which kind of `constants
<constants>` each type supports:

[cols=",,",options="header",]
|===
|type |constants supported |description
a|
____
`ascii`
____

a|
____
`string`
____

a|
____
ASCII character string
____

a|
____
`bigint`
____

a|
____
`integer`
____

a|
____
64-bit signed long
____

a|
____
`blob`
____

a|
____
`blob`
____

a|
____
Arbitrary bytes (no validation)
____

a|
____
`boolean`
____

a|
____
`boolean`
____

a|
____
Either `true` or `false`
____

a|
____
`counter`
____

a|
____
`integer`
____

a|
____
Counter column (64-bit signed value). See `counters` for details
____

a|
____
`date`
____

a|
____
`integer`, `string`
____

a|
____
A date (with no corresponding time value). See `dates` below for details
____

a|
____
`decimal`
____

a|
____
`integer`, `float`
____

a|
____
Variable-precision decimal
____

a|
____
`double`
____

a|
____
`integer` `float`
____

a|
____
64-bit IEEE-754 floating point
____

a|
____
`duration`
____

a|
____
`duration`,
____

a|
____
A duration with nanosecond precision. See `durations` below for details
____

a|
____
`float`
____

a|
____
`integer`, `float`
____

a|
____
32-bit IEEE-754 floating point
____

a|
____
`inet`
____

a|
____
`string`
____

a|
____
An IP address, either IPv4 (4 bytes long) or IPv6 (16 bytes long). Note
that there is no `inet` constant, IP address should be input as strings
____

a|
____
`int`
____

a|
____
`integer`
____

a|
____
32-bit signed int
____

a|
____
`smallint`
____

a|
____
`integer`
____

a|
____
16-bit signed int
____

a|
____
`text`
____

a|
____
`string`
____

a|
____
UTF8 encoded string
____

a|
____
`time`
____

a|
____
`integer`, `string`
____

a|
____
A time (with no corresponding date value) with nanosecond precision. See
`times` below for details
____

a|
____
`timestamp`
____

a|
____
`integer`, `string`
____

a|
____
A timestamp (date and time) with millisecond precision. See `timestamps`
below for details
____

a|
____
`timeuuid`
____

a|
____
`uuid`
____

a|
____
Version 1
https://en.wikipedia.org/wiki/Universally_unique_identifier[UUID],
generally used as a “conflict-free” timestamp. Also see
`timeuuid-functions`
____

a|
____
`tinyint`
____

a|
____
`integer`
____

a|
____
8-bit signed int
____

a|
____
`uuid`
____

a|
____
`uuid`
____

a|
____
A https://en.wikipedia.org/wiki/Universally_unique_identifier[UUID] (of
any version)
____

a|
____
`varchar`
____

a|
____
`string`
____

a|
____
UTF8 encoded string
____

a|
____
`varint`
____

a|
____
`integer`
____

a|
____
Arbitrary-precision integer
____

|===

=== Counters

The `counter` type is used to define _counter columns_. A counter column
is a column whose value is a 64-bit signed integer and on which 2
operations are supported: incrementing and decrementing (see the
`UPDATE statement
<update-statement>` for syntax). Note that the value of a counter cannot
be set: a counter does not exist until first incremented/decremented,
and that first increment/decrement is made as if the prior value was 0.

[[counter-limitations]]
Counters have a number of important limitations:

* They cannot be used for columns part of the `PRIMARY KEY` of a table.
* A table that contains a counter can only contain counters. In other
words, either all the columns of a table outside the `PRIMARY KEY` have
the `counter` type, or none of them have it.
* Counters do not support `expiration <ttls>`.
* The deletion of counters is supported, but is only guaranteed to work
the first time you delete a counter. In other words, you should not
re-update a counter that you have deleted (if you do, proper behavior is
not guaranteed).
* Counter updates are, by nature, not
https://en.wikipedia.org/wiki/Idempotence[idemptotent]. An important
consequence is that if a counter update fails unexpectedly (timeout or
loss of connection to the coordinator node), the client has no way to
know if the update has been applied or not. In particular, replaying the
update may or may not lead to an over count.

[[timestamps]]
== Working with timestamps

Values of the `timestamp` type are encoded as 64-bit signed integers
representing a number of milliseconds since the standard base time known
as https://en.wikipedia.org/wiki/Unix_time[the epoch]: January 1 1970 at
00:00:00 GMT.

Timestamps can be input in CQL either using their value as an `integer`,
or using a `string` that represents an
https://en.wikipedia.org/wiki/ISO_8601[ISO 8601] date. For instance, all
of the values below are valid `timestamp` values for Mar 2, 2011, at
04:05:00 AM, GMT:

* `1299038700000`
* `'2011-02-03 04:05+0000'`
* `'2011-02-03 04:05:00+0000'`
* `'2011-02-03 04:05:00.000+0000'`
* `'2011-02-03T04:05+0000'`
* `'2011-02-03T04:05:00+0000'`
* `'2011-02-03T04:05:00.000+0000'`

The `+0000` above is an RFC 822 4-digit time zone specification; `+0000`
refers to GMT. US Pacific Standard Time is `-0800`. The time zone may be
omitted if desired (`'2011-02-03 04:05:00'`), and if so, the date will
be interpreted as being in the time zone under which the coordinating
Cassandra node is configured. There are however difficulties inherent in
relying on the time zone configuration being as expected, so it is
recommended that the time zone always be specified for timestamps when
feasible.

The time of day may also be omitted (`'2011-02-03'` or
`'2011-02-03+0000'`), in which case the time of day will default to
00:00:00 in the specified or default time zone. However, if only the
date part is relevant, consider using the `date <dates>` type.

[[dates]]
== Working with dates

Values of the `date` type are encoded as 32-bit unsigned integers
representing a number of days with “the epoch” at the center of the
range (2^31). Epoch is January 1st, 1970

As for `timestamp <timestamps>`, a date can be input either as an
`integer` or using a date `string`. In the later case, the format should
be `yyyy-mm-dd` (so `'2011-02-03'` for instance).

[[times]]
== Working with times

Values of the `time` type are encoded as 64-bit signed integers
representing the number of nanoseconds since midnight.

As for `timestamp <timestamps>`, a time can be input either as an
`integer` or using a `string` representing the time. In the later case,
the format should be `hh:mm:ss[.fffffffff]` (where the sub-second
precision is optional and if provided, can be less than the nanosecond).
So for instance, the following are valid inputs for a time:

* `'08:12:54'`
* `'08:12:54.123'`
* `'08:12:54.123456'`
* `'08:12:54.123456789'`

[[durations]]
== Working with durations

Values of the `duration` type are encoded as 3 signed integer of
variable lengths. The first integer represents the number of months, the
second the number of days and the third the number of nanoseconds. This
is due to the fact that the number of days in a month can change, and a
day can have 23 or 25 hours depending on the daylight saving.
Internally, the number of months and days are decoded as 32 bits
integers whereas the number of nanoseconds is decoded as a 64 bits
integer.

A duration can be input as:

____
. `(quantity unit)+` like `12h30m` where the unit can be:
+
____
* `y`: years (12 months)
* `mo`: months (1 month)
* `w`: weeks (7 days)
* `d`: days (1 day)
* `h`: hours (3,600,000,000,000 nanoseconds)
* `m`: minutes (60,000,000,000 nanoseconds)
* `s`: seconds (1,000,000,000 nanoseconds)
* `ms`: milliseconds (1,000,000 nanoseconds)
* `us` or `µs` : microseconds (1000 nanoseconds)
* `ns`: nanoseconds (1 nanosecond)
____
. ISO 8601 format: `P[n]Y[n]M[n]DT[n]H[n]M[n]S or P[n]W`
. ISO 8601 alternative format: `P[YYYY]-[MM]-[DD]T[hh]:[mm]:[ss]`
____

For example:

[source,cql]
----
INSERT INTO RiderResults (rider, race, result) VALUES ('Christopher Froome', 'Tour de France', 89h4m48s);
INSERT INTO RiderResults (rider, race, result) VALUES ('BARDET Romain', 'Tour de France', PT89H8M53S);
INSERT INTO RiderResults (rider, race, result) VALUES ('QUINTANA Nairo', 'Tour de France', P0000-00-00T89:09:09);
----

[[duration-limitation]]
Duration columns cannot be used in a table's `PRIMARY KEY`. This
limitation is due to the fact that durations cannot be ordered. It is
effectively not possible to know if `1mo` is greater than `29d` without
a date context.

A `1d` duration is not equals to a `24h` one as the duration type has
been created to be able to support daylight saving.

== Collections

CQL supports 3 kind of collections: `maps`, `sets` and `lists`. The
types of those collections is defined by:

collection_type: MAP '<' [.title-ref]#cql_type# ','
[.title-ref]#cql_type# '>' : | SET '<' [.title-ref]#cql_type# '>' : |
LIST '<' [.title-ref]#cql_type# '>'

and their values can be inputd using collection literals:

collection_literal: [.title-ref]#map_literal# |
[.title-ref]#set_literal# | [.title-ref]#list_literal# map_literal: '\{'
[ [.title-ref]#term# ':' [.title-ref]#term# (',' [.title-ref]#term# :
[.title-ref]#term#)* ] '}' set_literal: '\{' [ [.title-ref]#term# (','
[.title-ref]#term#)* ] '}' list_literal: '[' [ [.title-ref]#term# (','
[.title-ref]#term#)* ] ']'

Note however that neither `bind_marker` nor `NULL` are supported inside
collection literals.

=== Noteworthy characteristics

Collections are meant for storing/denormalizing relatively small amount
of data. They work well for things like “the phone numbers of a given
user”, “labels applied to an email”, etc. But when items are expected to
grow unbounded (“all messages sent by a user”, “events registered by a
sensor”...), then collections are not appropriate and a specific table
(with clustering columns) should be used. Concretely, (non-frozen)
collections have the following noteworthy characteristics and
limitations:

* Individual collections are not indexed internally. Which means that
even to access a single element of a collection, the while collection
has to be read (and reading one is not paged internally).
* While insertion operations on sets and maps never incur a
read-before-write internally, some operations on lists do. Further, some
lists operations are not idempotent by nature (see the section on
`lists <lists>` below for details), making their retry in case of
timeout problematic. It is thus advised to prefer sets over lists when
possible.

Please note that while some of those limitations may or may not be
removed/improved upon in the future, it is a anti-pattern to use a
(single) collection to store large amounts of data.

=== Maps

A `map` is a (sorted) set of key-value pairs, where keys are unique and
the map is sorted by its keys. You can define and insert a map with:

[source,cql]
----
CREATE TABLE users (
    id text PRIMARY KEY,
    name text,
    favs map<text, text> // A map of text keys, and text values
);

INSERT INTO users (id, name, favs)
           VALUES ('jsmith', 'John Smith', { 'fruit' : 'Apple', 'band' : 'Beatles' });

// Replace the existing map entirely.
UPDATE users SET favs = { 'fruit' : 'Banana' } WHERE id = 'jsmith';
----

Further, maps support:

* Updating or inserting one or more elements:
+
[source,cql]
----
UPDATE users SET favs['author'] = 'Ed Poe' WHERE id = 'jsmith';
UPDATE users SET favs = favs + { 'movie' : 'Cassablanca', 'band' : 'ZZ Top' } WHERE id = 'jsmith';
----
* Removing one or more element (if an element doesn't exist, removing it
is a no-op but no error is thrown):
+
[source,cql]
----
DELETE favs['author'] FROM users WHERE id = 'jsmith';
UPDATE users SET favs = favs - { 'movie', 'band'} WHERE id = 'jsmith';
----
+
Note that for removing multiple elements in a `map`, you remove from it
a `set` of keys.

Lastly, TTLs are allowed for both `INSERT` and `UPDATE`, but in both
case the TTL set only apply to the newly inserted/updated elements. In
other words:

[source,cql]
----
UPDATE users USING TTL 10 SET favs['color'] = 'green' WHERE id = 'jsmith';
----

will only apply the TTL to the `{ 'color' : 'green' }` record, the rest
of the map remaining unaffected.

=== Sets

A `set` is a (sorted) collection of unique values. You can define and
insert a map with:

[source,cql]
----
CREATE TABLE images (
    name text PRIMARY KEY,
    owner text,
    tags set<text> // A set of text values
);

INSERT INTO images (name, owner, tags)
            VALUES ('cat.jpg', 'jsmith', { 'pet', 'cute' });

// Replace the existing set entirely
UPDATE images SET tags = { 'kitten', 'cat', 'lol' } WHERE name = 'cat.jpg';
----

Further, sets support:

* Adding one or multiple elements (as this is a set, inserting an
already existing element is a no-op):
+
[source,cql]
----
UPDATE images SET tags = tags + { 'gray', 'cuddly' } WHERE name = 'cat.jpg';
----
* Removing one or multiple elements (if an element doesn't exist,
removing it is a no-op but no error is thrown):
+
[source,cql]
----
UPDATE images SET tags = tags - { 'cat' } WHERE name = 'cat.jpg';
----

Lastly, as for `maps <maps>`, TTLs if used only apply to the newly
inserted values.

=== Lists

[NOTE]
.Note
====
As mentioned above and further discussed at the end of this section,
lists have limitations and specific performance considerations that you
should take into account before using them. In general, if you can use a
`set <sets>` instead of list, always prefer a set.
====A `list` is a (sorted) collection of non-unique values where
elements are ordered by there position in the list. You can define and
insert a list with:

[source,cql]
----
CREATE TABLE plays (
    id text PRIMARY KEY,
    game text,
    players int,
    scores list<int> // A list of integers
)

INSERT INTO plays (id, game, players, scores)
           VALUES ('123-afde', 'quake', 3, [17, 4, 2]);

// Replace the existing list entirely
UPDATE plays SET scores = [ 3, 9, 4] WHERE id = '123-afde';
----

Further, lists support:

* Appending and prepending values to a list:
+
[source,cql]
----
UPDATE plays SET players = 5, scores = scores + [ 14, 21 ] WHERE id = '123-afde';
UPDATE plays SET players = 6, scores = [ 3 ] + scores WHERE id = '123-afde';
----
* Setting the value at a particular position in the list. This imply
that the list has a pre-existing element for that position or an error
will be thrown that the list is too small:
+
[source,cql]
----
UPDATE plays SET scores[1] = 7 WHERE id = '123-afde';
----
* Removing an element by its position in the list. This imply that the
list has a pre-existing element for that position or an error will be
thrown that the list is too small. Further, as the operation removes an
element from the list, the list size will be diminished by 1, shifting
the position of all the elements following the one deleted:
+
[source,cql]
----
DELETE scores[1] FROM plays WHERE id = '123-afde';
----
* Deleting _all_ the occurrences of particular values in the list (if a
particular element doesn't occur at all in the list, it is simply
ignored and no error is thrown):
+
[source,cql]
----
UPDATE plays SET scores = scores - [ 12, 21 ] WHERE id = '123-afde';
----

[WARNING]
.Warning
====
The append and prepend operations are not idempotent by nature. So in
particular, if one of these operation timeout, then retrying the
operation is not safe and it may (or may not) lead to
appending/prepending the value twice.
====[WARNING]
.Warning
====
Setting and removing an element by position and removing occurences of
particular values incur an internal _read-before-write_. They will thus
run more slowly and take more ressources than usual updates (with the
exclusion of conditional write that have their own cost).
====Lastly, as for `maps <maps>`, TTLs when used only apply to the newly
inserted values.

[[udts]]
== User-Defined Types

CQL support the definition of user-defined types (UDT for short). Such a
type can be created, modified and removed using the
`create_type_statement`, `alter_type_statement` and
`drop_type_statement` described below. But once created, a UDT is simply
referred to by its name:

user_defined_type: [.title-ref]#udt_name# udt_name: [
[.title-ref]#keyspace_name# '.' ] [.title-ref]#identifier#

=== Creating a UDT

Creating a new user-defined type is done using a `CREATE TYPE` statement
defined by:

create_type_statement: CREATE TYPE [ IF NOT EXISTS ]
[.title-ref]#udt_name# : '(' [.title-ref]#field_definition# ( ','
[.title-ref]#field_definition# )* ')' field_definition:
[.title-ref]#identifier# [.title-ref]#cql_type#

A UDT has a name (used to declared columns of that type) and is a set of
named and typed fields. Fields name can be any type, including
collections or other UDT. For instance:

[source,cql]
----
CREATE TYPE phone (
    country_code int,
    number text,
)

CREATE TYPE address (
    street text,
    city text,
    zip text,
    phones map<text, phone>
)

CREATE TABLE user (
    name text PRIMARY KEY,
    addresses map<text, frozen<address>>
)
----

Note that:

* Attempting to create an already existing type will result in an error
unless the `IF NOT EXISTS` option is used. If it is used, the statement
will be a no-op if the type already exists.
* A type is intrinsically bound to the keyspace in which it is created,
and can only be used in that keyspace. At creation, if the type name is
prefixed by a keyspace name, it is created in that keyspace. Otherwise,
it is created in the current keyspace.
* As of Cassandra , UDT have to be frozen in most cases, hence the
`frozen<address>` in the table definition above. Please see the section
on `frozen <frozen>` for more details.

=== UDT literals

Once a used-defined type has been created, value can be input using a
UDT literal:

udt_literal: '\{' [.title-ref]#identifier# ':' [.title-ref]#term# ( ','
[.title-ref]#identifier# ':' [.title-ref]#term# )* '}'

In other words, a UDT literal is like a `map <maps>` literal but its
keys are the names of the fields of the type. For instance, one could
insert into the table define in the previous section using:

[source,cql]
----
INSERT INTO user (name, addresses)
          VALUES ('z3 Pr3z1den7', {
              'home' : {
                  street: '1600 Pennsylvania Ave NW',
                  city: 'Washington',
                  zip: '20500',
                  phones: { 'cell' : { country_code: 1, number: '202 456-1111' },
                            'landline' : { country_code: 1, number: '...' } }
              },
              'work' : {
                  street: '1600 Pennsylvania Ave NW',
                  city: 'Washington',
                  zip: '20500',
                  phones: { 'fax' : { country_code: 1, number: '...' } }
              }
          })
----

To be valid, a UDT literal should only include fields defined by the
type it is a literal of, but it can omit some field (in which case those
will be `null`).

=== Altering a UDT

An existing user-defined type can be modified using an `ALTER TYPE`
statement:

alter_type_statement: ALTER TYPE [.title-ref]#udt_name#
[.title-ref]#alter_type_modification# alter_type_modification: ADD
[.title-ref]#field_definition# : | RENAME [.title-ref]#identifier# TO
[.title-ref]#identifier# ( [.title-ref]#identifier# TO
[.title-ref]#identifier# )*

You can:

* add a new field to the type (`ALTER TYPE address ADD country text`).
That new field will be `null` for any values of the type created before
the addition.
* rename the fields of the type
(`ALTER TYPE address RENAME zip TO zipcode`).

=== Dropping a UDT

You can drop an existing user-defined type using a `DROP TYPE`
statement:

drop_type_statement: DROP TYPE [ IF EXISTS ] [.title-ref]#udt_name#

Dropping a type results in the immediate, irreversible removal of that
type. However, attempting to drop a type that is still in use by another
type, table or function will result in an error.

If the type dropped does not exist, an error will be returned unless
`IF EXISTS` is used, in which case the operation is a no-op.

== Tuples

CQL also support tuples and tuple types (where the elements can be of
different types). Functionally, tuples can be though as anonymous UDT
with anonymous fields. Tuple types and tuple literals are defined by:

tuple_type: TUPLE '<' [.title-ref]#cql_type# ( ','
[.title-ref]#cql_type# )* '>' tuple_literal: '(' [.title-ref]#term# (
',' [.title-ref]#term# )* ')'

and can be used thusly:

[source,cql]
----
CREATE TABLE durations (
    event text,
    duration tuple<int, text>,
)

INSERT INTO durations (event, duration) VALUES ('ev1', (3, 'hours'));
----

Unlike other "composed" types (collections and UDT), a tuple is always
`frozen <frozen>` (without the need of the [.title-ref]#frozen# keyword)
and it is not possible to update only some elements of a tuple (without
updating the whole tuple). Also, a tuple literal should always have the
same number of value than declared in the type it is a tuple of (some of
those values can be null but they need to be explicitly declared as so).

== Custom Types

[NOTE]
.Note
====
Custom types exists mostly for backward compatiliby purposes and their
usage is discouraged. Their usage is complex, not user friendly and the
other provided types, particularly `user-defined types <udts>`, should
almost always be enough.
====A custom type is defined by:

custom_type: [.title-ref]#string#

A custom type is a `string` that contains the name of Java class that
extends the server side `AbstractType` class and that can be loaded by
Cassandra (it should thus be in the `CLASSPATH` of every node running
Cassandra). That class will define what values are valid for the type
and how the time sorts when used for a clustering column. For any other
purpose, a value of a custom type is the same than that of a `blob`, and
can in particular be input using the `blob` literal syntax.
